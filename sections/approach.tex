% !TeX root = ../paper.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

\section{Approach}\label{sec:approach}
 
\subsection{OCDDISCOVER}
\begin{itemize}
	\item Idea: OD = OCD + FD
	\item Pruning rules used to build search tree
	\item Where was their mistake?
\end{itemize}

\subsection{Our architecture}
\begin{itemize}
	\item Whole system
	\begin{itemize}
		\item Peer-to-peer after seednode shared data
		\item Every node holds all data
		\item Workstealing
		\item State Replication
	\end{itemize}
	\item Within every Node
	\begin{itemize}
		\item Master Worker
		\item Master holds state (Candidate queue) + does Workstealing
		\item Pull-based work distribution
		\item State Replicator for sharing and recovering states (via streaming)
		\item Data Holder for holding and sharing data (via streaming)
		\item ClusterListener to support node to node communication
		\item ResultCollector saves results to file (still need to be merged and reduced to unique results in the end)
		\item Reaper
	\end{itemize}
\end{itemize}

\subsection{Communication Protocols}
% Questions to be answered for each one:
% What is its purpose? 
% When is the protocol started and what is the desired outcome? 
% Who is communicating? 
% What Messages are being used?
% What cases need to be covered? (Early outs etc)

\subsubsection{Work Stealing Protocol}
% Possible picture (sequence diagram): https://sequencediagram.org/index.html#initialData=C4S2BsFMAIHUHsBOBraBlYkCG4QDsBzaABUXmHgGN5wAoWgFQAsRIAzaPeAE0gFoAfF17QATAC4A4pGAIU4eFm6MW7Tj35CN0AMxSZc5AqUrWHYZovQALPtlIji5VdGDmZ9b3GHj3ABQAjAAMAJS0VjpuquYa3g6+fgBsYVbWUR4WcfJOfgAcYe5qFulFsQwgALaQ8ACuwKalvIIu4hjY4IZ+1gXRnpbatm04naIp2q4ChTFeGDSQeJ3W0JRYeNwg3FiYAM5jImmTvZmzUAsOfqLLq+ubOz0ZGs3j4gCClMgn84YN0-37r+9PmcUEA
When a node is out of work, either because it just joined the cluster or because all the candidates it checked got pruned and did not generate any new candidates to check, it tries to take over some of the work of the other nodes. 
This process is called \emph{Work Stealing}.
We use it to ensure that no node is idle while the others are still checking candidates and to balance the workload over the cluster. 
The workload of a node is defined by the number of candidates waiting to be processed in its queue. 
In the desired outcome to add to its own queue of the \emph{Work Stealing Protocol}, each node ends up with a similar workload. 
To achieve this goal the \emph{Master Actors} of the different nodes communicate their workloads with each other.\\
The \emph{Work Stealing Protocol} is initiated when a node's \emph{Candidate Queue} is empty, even if some of its workers are still processing candidates and might return new ones soon.
This node (the \emph{Thief node}) sends a message to all other nodes, asking for the current size of their \emph{Candidate Queues}.
It also sets a timeout after which it processes the answers of the other nodes. 
During this processing step it calculates the average \emph{Candidate Queue's} length of all the nodes that answered and itself.
To improve the balancing of workloads over the cluster, the \emph{Thief node} only takes candidates from nodes that have a \emph{Candidate Queue} of above average length and only takes so many candidates that its own \emph{Candidate Queue's} length does not exceed the average. 
% Explain in more detail / with pseudocode?
To get the candidates from another node's \emph{Candidate Queue}, the \emph{Thief node} sends a message with the amount of candidates it wants to take to the node it wants to take them from.
This node, the \emph{Victim node}, then moves the asked for candidates from its \emph{Candidate Queue} into its \emph{Pending Queue} and sends them to the \emph{Thief node}.
However, since the \emph{Victim node's} queue might have changed since it first sent its length to the \emph{Thief node}, the \emph{Victim node} sends back at most half of the candidates in its queue.
Once the \emph{Thief node} receives the candidates, it adds them to its own queue and sends a message acknowledging the receipt to the \emph{Victim node}, which then deletes the candidates from its \emph{Pending queue}. 
To ensure the send candidates arrive and will get processed, the \emph{Victim node} watches the \emph{Thief node}.
In the case that the \emph{Thief node} failes before it could acknowledge the receipt of the candidates, the \emph{Victim node} moves them back to its own \emph{Candidate queue} from its \emph{Pending queue}.
 
\subsubsection{Downing Protocol}

\subsubsection{State Replication Protocol}
To ensure any of the nodes of the cluster can fail without any work getting lost, every node regularly replicates its state to two other nodes.
Because of this, three specific nodes would have to fail simultaneously to permanently lose any unprocessed candidates. 
In this case, everything would need to be restarted to ensure complete results. \\
Which nodes the state is sent to is decided by their addresses.
All nodes in a cluster are ordered by their addresses and every node replicates its state to both its neighbours in this ordering.
The first and last node in this ordering are also each others neighbours.\\
Every node has a \emph{State Replication Actor} responsible for regularly sending the node's state to its neighbours and processing these neighbour's states when they are sent. 
It gets the information of who its neighbours are from the \emph{Cluster Listener Actor}. \\
In regular intervals, the \emph{State Replicator} asks the \emph{Master Actor} for its current state.
The state is a combination of its \emph{Candidate Queue} and \emph{Pending Queue}.
On receiving the \emph{Master's} current state, the \emph{State Replicator} sends to both its neighbours with a version number that is continually increased.\\
When a \emph{State Replicator} receives the state of one of its neighbours, it checks whether the version number in the new message is higher than the version number of the last state it received from that actor.
If this is the case, it saves the new state and version number.
If not, is discards the new message, because it already has a more up to date state for that actor. \\
\paragraph{A node joins the cluster}
When a new node joins the cluster, the \emph{Cluster Listener} updates its ordering of all the nodes in the cluster. 
It then sends the \emph{State Replicator} the updated neighbour information.
If the nodes neighbour has changed, the \emph{State Replicator} removes the state of the node that is no longer its neighbour and sends its own state to its new neighbour.
\paragraph{A node leaves the cluster}
When a node leaves the cluster, its two neighbours have to decide which of them will take on the work the leaving node did not finish. 
They are alerted to their neighbour's leaving by the \emph{Cluster Listener} who also immediately tells them, who their new neighbour is. 
This new neighbour was the leaving nodes other neighbour.
To determine which of the two has the most up to date state of the leaving node, they share the version number of the leaving node's state. 
The node with the higher version number adds the leaving nodes state to its own \emph{Candidate Queue} to ensure all candidates get processed. 
The node with the lower version number deletes the state of the leaving node.
The two nodes then share their state with each other. 